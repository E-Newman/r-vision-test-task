= Работа с языком

:navtitle: Работа с языком

В данном разделе представлены основные аспекты использования языка запросов Omega SIEM для анализа данных о событиях. Описаны методы создания запросов, применение условий, управление выводом результатов и их сортировка, а также техники работы с проекциями и заполнение данных. Это включает применение фильтров, временных ограничений и формирование запросов в контексте дашбордов.

*Содержание раздела:*

* xref:#creating-queries[Создание запросов]
** xref:#using-conditions[Использование условий]
** xref:#max-records-sorting[Максимальное количество возвращаемых записей и сортировка]
** xref:#working-with-projections[Работа с проекциями]
** xref:#filling-gaps[Заполнение пропусков в списке возвращаемых результатов]
* xref:#use-filtes-time-limits[Использование фильтров и ограничений по времени]
* xref:#create-query-dashboard[Создание запросов в дашбордах]
* xref:#working-with-active-lists[Работа с активными списками]


== Создание запросов
[#creating-queries]

=== Использование условий
[#using-conditions]

В SQL в состав запроса необходимо включать указание на таблицу БД, к которой обращается запрос.
В системе Omega SIEM для каждого xref:getting_started:EventStorage.adoc[хранилища событий] в системе выбирается xref:getting_started:EventModel.adoc[модель
событий], определяющая формат хранения данных. Работа в разделе xref:Events.adoc[События] возможна только в определенном хранилище.

Когда вы задаете временной диапазон поиска событий, оставляя незаполненным поле поиска, и нажимаете кнопку *Поиск*
при пустом поле поиска, система по умолчанию выполняет поиск по *всем* полям текущей модели данных независимо от того,
какие поля отображаются в списке xref:Events.adoc[событий].

Таким образом, из стандартного запроса с выборкой по определенному условию вида `SELECT * FROM table WHERE` в рамках системы
исключаются компоненты `SELECT *` и `FROM table`. Система обращается к таблице, соответствующей выбранной модели данных, выполняя
поиск по всем полям. Запрос с выборкой по определенному условию в системе сводится к заданию условия `WHERE`. Совмещение
нескольких условий происходит стандартно, с использованием операторов и функций языка запросов AQL.

Пример:

Запрос, возвращающий события, у которых значения в поле `tenantId` начинаются с символа n, а количество символов в поле
`raw` превышает 10.

[source,sql]
----
SELECT * FROM table WHERE tenantId LIKE 'n%' AND length(raw) > 10
----

Запрос в системе:

[source,sql]
----
tenantId LIKE 'n%' AND length(raw) > 10
----


=== Максимальное количество возвращаемых записей и сортировка
[#max-records-sorting]

По умолчанию в списке результатов поискового запроса отображается 500 записей. Вы можете ограничить количество
возвращаемых записей с помощью оператора `LIMIT`. Например, ограничение количества записей до 20 выполняется запросом:
`LIMIT 20`. При этом также можно добавить команду `OFFSET`, указывающую, сколько строк необходимо пропустить
перед началом вывода строк.

Возможна сортировка выборки по любому полю с помощью команды `ORDER BY`. Например, чтобы отсортировать события по полю
`collectorId`, введите запрос: `ORDER BY collectorId`.

=== Работа с проекциями
[#working-with-projections]

При использовании команды объединения результатов выборки обязательно нужно указывать проекцию, к которой будет
применено объединение. Например, запрос вида `GROUP BY tenantID` воспринимается системой как `SELECT * GROUP BY tenantID`
и поэтому является некорректным. Корректный запрос с указанной проекцией имеет вид: `SELECT tenantID GROUP BY tenantID`.

С оператором `GROUP BY` в поисковых запросах очень часто применяются агрегатные функции (`COUNT, SUM, AVG, MAX, MIN`).

Использование проекций позволяет применять запрос с выборкой по определенному условию к указанному полю.

TIP: Оператор `WHERE` можно использовать в запросе, если после него указывается условие.

Пример 1. Запрос `SELECT tenantId WHERE length(tenantId) = 5` возвращает события с количеством символов в поле `tenantId`
равным 5.

Пример 2. Запрос `SELECT tenantId, count(*) ORDER BY tenantId ASC` возвращает события, отсортированные по полю `tenantId` с
сортировкой по возрастанию и указанием количества событий в каждой группе.

*Соответствие запросов языка системы и SQL*:

|===
|Стандартный запрос |Запрос в системе

|SELECT tenantId FROM table
|SELECT tenantId

|SELECT tenantId FROM table WHERE length(tenantId) = 5
|SELECT tenantId WHERE length(tenantId) = 5

|SELECT tenantId, count(*) FROM table GROUP BY tenantId
|SELECT tenantId, count(*) GROUP BY tenantId

|===

=== Заполнение пропусков в списке возвращаемых результатов
[#filling-gaps]

При сортировке и группировке записей можно использовать модификатор `WITH FILL` для заполнения пропусков в списке возвращаемых результатов.

Модификатор `WITH FILL` может быть использован после `ORDER BY expr` с опциональными параметрами `FROM expr`, `TO expr` и `STEP expr`. Все пропущенные записи для колонки `expr` будут заполнены значениями, соответствующими предполагаемой последовательности записей колонки, другие колонки будут заполнены записями по умолчанию.

Можно использовать следующие варианты синтаксиса:

- `ORDER BY field_name WITH FILL`: сортировка по полю с заполнением отсутствующих групп результатов с использованием значений по умолчанию для данного типа данных.
- `ORDER BY field_name WITH FILL STEP expr`: сортировка по полю с заполнением отсутствующих групп результатов с указанным шагом для данного типа данных.
- `ORDER BY field_name WITH FILL FROM expr TO expr STEP expr`: сортировка по полю с заполнением отсутствующих групп результатов с указанным шагом в указанном промежутке для данного типа данных.

Здесь `field_name` - имя поля, по которому происходит сортировка, а `expr` - выражение, которое определяет значения для заполнения пропущенных записей. `FROM expr` - задает начальное значение интервала, который будет заполнен, `TO expr` - задает конечное значение, `STEP expr` - задает шаг, с которым будет заполняться интервал.

Ограничения:

- `expr` - числовой литерал (целое или дробное), дата-время, арифметическая операция с числами или датой-временем (и интервалом или функцией), функция с возвращаемым значением в виде числа или даты-времени.
- `WITH FILL` может быть применен только после имени колонки в `ORDER BY`. Допускается использование нескольких `WITH FILL` для разных колонок.

TIP: Для случая с несколькими полями `ORDER BY field2 WITH FILL, field1 WITH FILL` порядок заполнения будет соответствовать порядку полей в секции `ORDER BY`.

Пример 1:

[source,sql]
----
SELECT toStartOfHour(timestamp) as ts, sum(cnt) as sum_cnt GROUP BY ts HAVING sum_cnt > 0 ORDER BY ts WITH FILL FROM now() - INTERVAL 1 day TO now() STEP INTERVAL 1 hour
----

Данный запрос выполняет следующую последовательность операций:

- `SELECT toStartOfHour(timestamp) as ts, sum(cnt) as sum_cnt`: выбираются значения поля `timestamp`, округленные до начала каждого часа, и вычисляется сумма поля `cnt` для каждой группы записей с одинаковым значением `ts`.

- `GROUP BY ts`: результаты группируются по полю `ts`, которое представляет округленные значения.

- `HAVING sum_cnt > 0`: применяется фильтр, чтобы оставить только те группы записей, у которых сумма поля `cnt` больше нуля. Это означает, что в результирующем наборе будут только записи, для которых существуют записи с положительными значениями `cnt` внутри группы.

- `ORDER BY ts WITH FILL FROM now() - INTERVAL 1 day TO now() STEP INTERVAL 1 hour`: результаты сортируются по полю `ts`. Здесь используется модификатор `WITH FILL`, который обеспечивает заполнение пропущенных интервалов с шагом в 1 час от текущего времени минус 1 день до текущего времени. То есть, если в исходных данных отсутствуют записи для определенных интервалов времени, то они будут включены в результирующий набор со значениями по умолчанию.

Пример 2:

[source,sql]
----
SELECT toStartOfHour(timestamp) as ts, sum(cnt) as sum_cnt GROUP BY ts HAVING sum_cnt > 0 AND ts >= now() - INTERVAL 1 day AND ts <= now() ORDER BY ts WITH FILL FROM now() - INTERVAL 1 day TO now() STEP INTERVAL 1 hour
----

Здесь выполняются те же самые операции, что и в первом запросе, но добавляется дополнительный фильтр в выражении `HAVING` и выражении `AND`. Этот фильтр ограничивает результаты только записями, у которых поле `ts` находится в интервале от текущего времени минус 1 день до текущего времени. Таким образом, данный запрос дополнительно фильтрует записи по временному интервалу перед применением сортировки и заполнения пропущенных интервалов.

В результате выполнения этого запроса будет получен отсортированный список записей, где каждая запись будет содержать округленное значение `timestamp`, сумму `cnt` для соответствующей группы записей, а также пропущенные интервалы времени со значениями по умолчанию, если таковые имеются. В результирующем наборе будут только записи, удовлетворяющие условиям фильтрации по сумме `cnt` и временному интервалу.

== Использование фильтров и ограничений по времени
[#use-filtes-time-limits]


После выполнения запроса данных в таблице событий системы можно xref:events:Events.adoc#add-user-filter[отфильтровать]
возвращенные результаты с помощью кнопки *Добавить фильтр*. В окне добавления фильтра указывается поле, по которому
проводится фильтрация, оператор сравнения и значение для сравнения. Система воспринимает применяемый фильтр как
дополнительный компонент в строке поискового запроса, которому предшествует оператор `AND`.

==== Примеры использования

Пример 1. Вы ввели в строке поиска запрос `tenantId like 'n%' AND length(raw) > 10`. Затем добавили фильтр по полю
`originalTimestamp` c оператором `=` и значением `05.05.2023, 05:00:00`. Последовательность этих действий равнозначна
следующему запросу в строке поиска: `tenantId like 'n%' AND length(raw) > 10 AND originalTimestamp = '2023.05.05 05:00:00'`.

Вместе с фильтрами удобно использовать функциональность xref:Events.adoc#find-events[ограничения] запроса по времени.
Ее применение аналогично добавлению к запросу компонента, помещающего результат запроса в указанные временные рамки.

Пример 2. Вы хотите ограничить результат запроса `tenantId like 'n%' AND length(raw) > 10` датами `01.01.2023` и `12.12.2023`.
Для этого нужно после выполнения запроса выбрать значение *Задать период* в поле периода и указать диапазон периода в полях
справа. Эти действия аналогичны запросу `tenantId like 'n%' AND length(raw) > 10 AND (timestamp >= 2023.01.01 AND timestamp <= 2023.12.12)`.

Таким образом, применение фильтров и ограничений по времени существенно упрощает создание поисковых запросов в системе.


== Создание запросов в дашбордах
[#create-query-dashboard]

При вводе поисковых запросов в поле *Запрос* в виджетах и метриках, создаваемых в дашбордах, активно используются проекции различных
колонок таблицы событий. При перечислении проекций, включенных в запрос, в системе в качестве разделителя используется
запятая.

IMPORTANT: Не ставьте разделитель после последней проекции, включенной в запрос.

|===
|Стандартный запрос |Запрос в системе

|SELECT tenantId, raw FROM table
|SELECT tenantId, raw

|SELECT tenantId, raw FROM table WHERE length(tenantId) = 5
|SELECT tenantId, raw WHERE length(tenantId) = 5
|===

Также используются псевдонимы, позволяющие сократить названия используемых компонентов запроса в разделе *Сопоставление
полей* при редактировании виджетов и метрик.

Пример. При редактировании виджета типа *Таблица* вводится запрос:
`SELECT collectorId, count(*) AS cnt WHERE collectorId like '%' GROUP BY collectorId`

Здесь для функции xref:AQLAggregateFunctions.adoc[count(*)] задается псевдоним `cnt`.
Когда вам необходимо указать эту функцию в разделе сопоставления полей, можно использовать ее псевдоним -- `cnt`.

== Работа с активными списками
[#working-with-active-lists]

Чтобы использовать данные из активных списков для фильтрации или дополнения результатов запроса к хранилищу событий, нужно применить оператор `JOIN`. В AQL поддерживаются следующие типы `JOIN`: `INNER JOIN, LEFT JOIN, RIGHT JOIN` и `FULL JOIN`. При выполнении `JOIN` хранилище событий всегда является левой таблицей, а активный список -- правой.

Пример:

Запрос, который возвращает события только для IP-адресов, замеченных в DDoS-атаках.

[source,sql]
----
SELECT * FROM event INNER JOIN DDoSAttackIPs ON event.sourceIp = DDoSAttackIPs.Ip
----

Запрос в системе:

[source,sql]
----
INNER JOIN DDoSAttackIPs ON event.sourceIp = DDoSAttackIPs.Ip
----

В данном примере был использован `INNER JOIN` -- тип `JOIN`, который возвращает только записи, соответствующие и хранилищу событий, и активному списку; в примере вернутся строки, соответствующие IP-адресам, которые и генерировали события, и были замечены в DDoS-атаках.

TIP: Для колонок можно использовать как синтаксис {имя_таблицы}.{имя_колонки}, так и синтаксис {имя_колонки}.

Пример использования синтаксиса {имя_колонки}:

[source,sql]
----
INNER JOIN DDoSAttackIPs ON sourceIp = Ip
----

IMPORTANT: В AQL явное указание типа `JOIN` обязательно; `INNER`, в отличие от других языков SQL-запросов, *не является* типом по умолчанию.

При использовании оператора `LEFT JOIN` будут возвращены все строки из хранилища событий и только те строки из активного списка, для которых выполнено условие, заданное в секции `ON`. Если в активном списке нет строки, соответствующей строке хранилища событий, в полях для данных из активного списка будут значения `NULL`.

Пример:

Запрос, который для событий, полученных от IP-адресов из белого списка, в дополнение к информации о событиях возвращает описание IP-адреса в поле `description`. Для адресов не из белого списка поле `description` будет содержать значение `NULL`.

[source,sql]
----
SELECT event.sourceIp, event.art, event.raw, wl.description LEFT JOIN whitelist_ips AS wl ON event.sourceIp = wl.Ip
----

TIP: Вместо имени активного списка можно использовать его псевдоним, указав его в секции `AS`.

При использовании оператора `RIGHT JOIN` будут возвращены все строки из активного списка и только те строки из хранилища событий, для которых выполнено условие в секции `ON`. Если в хранилище событий нет строки, соответствующей строке из активного списка, в полях для данных из хранилища событий будут значения `NULL`.

Пример:

Запрос, который возвращает список подозрительных IP-адресов, временные метки и текст событий начала их активности. Для подозрительных IP-адресов, не проявлявших активности, поля `art` и `raw` будут содержать значение `NULL`.

[source,sql]
----
SELECT sl.Ip, event.art, event.raw RIGHT JOIN suspicious_ips AS sl ON event.sourceIp = sl.Ip AND event.art = sl.activity_started_ts
----

TIP: Секция `ON` поддерживает составные условия, включающие операции сравнения и логические операции `AND` и `OR`, например, `event.col1 = al.col2 AND event.col3 > al.col4 OR event.col5 < al.col6`

При использовании оператора `FULL JOIN` будут возвращены все строки из хранилища событий и активного списка. Если в хранилище событий или активном списке нет строк, удовлетворяющих условию в секции `ON`, то возвращается `NULL` для соответствующих значений.

Пример:

Запрос, который возвращает описание событий с префиксом `Warning`, произошедших с момента времени 2024-05-23 00:00:00: IP-адреса, временные метки и текстовые сообщения событий, а для IP-адресов из активных списков `DDoSAttackIPs` и `ParserIPs` дополнительно текстовое описание этих адресов.

[source,sql]
----
SELECT event.sourceIp, event.art, event.raw, bl_ddos.description, bl_pars.description WHERE event.timestamp >= '2024-05-23 00:00:00' AND event.raw LIKE 'Warning%' FULL JOIN DDoSAttackIPs AS bl_ddos ON event.sourceIp = bl_ddos.Ip FULL JOIN ParserIPs as bl_pars ON event.sourceIp = bl_pars.Ip
----

TIP: Запрос выше иллюстрирует поддержку нескольких операторов `JOIN` в одном запросе, что позволяет объединять информацию из нескольких активных списков.